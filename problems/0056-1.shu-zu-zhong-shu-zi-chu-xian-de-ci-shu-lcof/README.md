# 数组中数字出现的次数

[原题链接](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

## 题目

一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

示例 1：
```text
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```

示例 2：
```text
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```

限制：

2 <= nums <= 10000

## 题解

![](https://cdn.jsdelivr.net/gh/zhangslob/oss@master/uPic/4PwxaB.png)

看到这道题我就想起了异或，之前有做过类似的题目，异或有一个性质：`a ^ b ^ a ^ c = b ^ c`

这样就可以把重复的a排除，得到`b ^ c`的值，然后我就卡在这里了。

这道题说时间复杂度是O(n)，我一直以为只能循环数组一遍，然后就怎么也想不出答案了。最后看了题解才知道，O(n)是可以循环两遍数组的，只要不是嵌套循环，时间复杂度都是O(n)。

由于异或的性质是，同一位相同则为 0，不同则为 1. 我们将所有数字异或的结果一定不是 0，也就是说至少有一位是 1.

我们随便取一个， 分组的依据就来了， 就是你取的那一位是 0 分成 1 组，那一位是 1 的分成一组。
这样肯定能保证2. 相同的数字分成相同组, 不同的数字会被分成不同组么。 很明显当然可以， 因此我们选择是 1，也就是
说两个独特的的数字在那一位一定是不同的，因此两个独特元素一定会被分成不同组。



## 代码

### Java

```java
public class Solution {
    public int[] singleNumbers(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum ^= num;
        }
        int first = 1;
        while ((sum & first) == 0) {
            first <<= 1;
        }
        // first为1，所以我们可以根据数组元素的二进制低位第一位是否为1，将数组分为2类，
        // 示例数组可以分为     低位第一位为0：[4,4,6]     低位第一位为1：[1]
        // 此时再将两个数组两两异或就可以得到最终结果。
        int[] result = new int[2];
        for (int num : nums) {
            //将数组分类。
            if ((num & first) == 0) {
                result[0] ^= num;
            } else {
                result[1] ^= num;
            }
        }
        return result;
    }
}
```

- 执行用时 : 1 ms , 在所有 Java 提交中击败了 100.00% 的用户 
- 内存消耗 : 41.5 MB , 在所有 Java 提交中击败了 100.00% 的用户

